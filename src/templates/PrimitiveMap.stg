PrimitiveMap(var) ::= <<
package $var.packageName$;

import java.util.Map;
import java.util.Arrays;
import java.util.RandomAccess;

/** A primitive $var.type$ implementation of a {@link Map}.<br>
 * Duplicate elements are not allowed.<br>
 * This class' purpose is to provide minor performance and memory usage improvements over an
 * {@code Map<$var.objectType$, T>} by storing the $var.objectType$s as type <code>$var.type$</code>
 * without converting them to $var.objectType$.
 * @param <T> the data type of the values stored in this map
 * @see $var.typeShortUpperCase$ArrayList
 * @see $var.typeShortUpperCase$Bag
 *
 * @author TeamworkGuy2
 * @since 2015-1-18
 */
@javax.annotation.Generated("StringTemplate")
public class $var.className$<T> implements $var.implementClassNames:{x | $x$, }; separator=", "$RandomAccess, Iterable<$var.objectType$> {
	protected int mod;
	protected $var.type$[] keys;
	protected $var.valueType$[] values;
	protected int size;


	/** Create an empty map
	 */
	public $var.className$() {
		this(16);
	}


	/** Create an empty map capable of holding specified number of items without needing to expand
	 * @param capacity the initial size of the map of items
	 */
	public $var.className$(int capacity) {
		this.keys = new $var.type$[capacity];
		this.values = new $var.type$[capacity];
		this.size = 0;
	}


	@Override
	public $var.className$ copy() {
		$var.className$ newList = new $var.className$(size);
		newList.size = size;
		System.arraycopy(key, 0, newList.key, 0, size);
		System.arraycopy(values, 0, newList.values, 0, size);
		return newList;
	}


	/** Get the integer at the specified index
	 * @param index the index between zero and {@link #size()}-1 inclusive to retrieve
	 * @return the integer found at the specified index
	 * @throws ArrayIndexOutOfBoundsException if the index is outside the range [0, {@link #size()}-1]
	 */
	@Override
	public $var.type$ get(int index) {
		if(index < 0 || index >= size) { throw new ArrayIndexOutOfBoundsException(index); }
		return data[index];
	}


	/** Get the index of the specified value in this sorted list if it exists
	 * @param value the value to search for in this list
	 * @return the index of the value if it ins contained in this list, else return -1
	 */
	@Override
	public int indexOf($var.type$ value) {
		int index = Arrays.binarySearch(data, 0, size, value);
		return index > -1 ? index : -1;
	}


	/** Check if the specified values is contained in this list of integers
	 * @param value the value to check for in this list
	 * @return true if the value was found in the list, false otherwise
	 */
	@Override
	public boolean contains($var.type$ value) {
		// Search for the item to remove
		int index = Arrays.binarySearch(data, 0, size, value);
		return (index > -1 && index < size);
	}


	/** Remove the integer at the specified index
	 * @param index the index between zero and {@link #size()}-1 inclusive to remove
	 * @return the integer found at the specified index
	 */
	@Override
	public $var.type$ remove(int index) {
		if(index < 0 || index >= size) {
			throw new ArrayIndexOutOfBoundsException(index);
		}
		// Shift all elements above the remove element to fill the empty index
		// Get the item to remove
		$var.type$ item = data[index];
		// Copy down the remaining upper half of the array if the item removed was not the last item in the array
		if(index < size - 1) {
			System.arraycopy(data, index + 1, data, index, size - index - 1);
		}
		// Decrease the size because we removed one item
		size--;
		mod++;
		return item;
	}


	/** Remove the specified value from this group
	 * @param item the value to remove
	 * @return true if the value was found and removed successfully, false otherwise
	 */
	@Override
	public boolean removeValue($var.type$ value) {
		// Search for the item to remove
		int index = indexOfValue(values, 0, size, value);
		if(index > -1 && index < size) {
			System.arraycopy(keys, index + 1, keys, index, size - index - 1);
			System.arraycopy(values, index + 1, values, index, size - index - 1);
			size--;
			mod++;
			return true;
		}
		return false;
	}


	/** Add the specified item to this group of elements
	 * @param item the item to add to this group of elements
	 */
	@Override
	public boolean pub($var.type$ key, $var.valueType$ value) {
		// If the list is to small, expand it
		if(size == keys.length) {
			expandList();
		}
		// Add the new item
		int index = Arrays.binarySearch(keys, 0, size, key);
		if(index < 0) { index = -index - 1; }
		if(index > size) { index = size; }
		System.arraycopy(keys, index, keys, index + 1, size - index);
		System.arraycopy(values, index, values, index + 1, size - index);
		keys[index] = key;
		values[index] = value;
		size++;
		mod++;
		return true;
	}


	public boolean addAll($var.type$[] items) {
		return addAll(items, 0, items.length);
	}


	public boolean addAll($var.type$[] items, int off, int len) {
		boolean res = true;
		for(int i = off, size = off + len; i < size; i++) {
			res &= add(items[i]);
		}
		mod++;
		return res;
	}


	/** Clear the group of elements
	 */
	@Override
	public void clear() {
		// Clear list to null
		for(int i = 0; i < size; i++) {
			keys[i] = $var.defaultValue$;
			values[i] = $var.defaultValueValue$;
		}
		// Set the size to zero
		size = 0;
		mod++;
	}


	/** Get the current size of this group of elements
	 * @return the size of this group of elements
	 */
	@Override
	public int size() {
		return size;
	}


	/** Is this group of elements empty
	 * @return true if this group of elements is empty, false otherwise
	 */
	@Override
	public boolean isEmpty() {
		return size == 0;
	}


	/*@Override
	public $var.type$[] toArray() {
		return toArray(new $var.type$[this.size], 0);
	}


	@Override
	public $var.type$[] toArray($var.type$[] dst, int dstOffset) {
		System.arraycopy(this.data, 0, dst, dstOffset, this.size);
		return dst;
	}


	@Override
	public $var.iteratorName$ iterator() {
		return new $var.iteratorName$(new $var.iteratorPrimitiveName$(this));
	}


	public $var.iteratorPrimitiveName$ iteratorPrimitive() {
		return new $var.iteratorPrimitiveName$(this);
	}*/


	private final void expandList() {
		$var.type$[] oldKeys = this.keys;
		$var.type$[] oldValues = this.values;
		// Increase the size by 1.5x + 4, +4 in case the size is 0 or 1,
		// +4 rather than +1 to prevent constantly expanding a small list
		int newSize = oldKeys.length + (oldKeys.length >\>> 1) + 1;
		this.keys = new $var.type$[newSize];
		this.values = new $var.type$[newSize];
		System.arraycopy(oldKeys, 0, this.keys, 0, size);
		System.arraycopy(oldValues, 0, this.values, 0, size);
	}


	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder(64);
		builder.append('[');
		if(size > 0) {
			int sizeTemp = size - 1;
			for(int i = 0; i < sizeTemp; i++) {
				builder.append(keys[i]);
				builder.append('=');
				builder.append(values[i]);
				builder.append(", ");
			}
			builder.append(keys[sizeTemp]);
			builder.append('=');
			builder.append(values[sizeTemp]);
		}
		builder.append(']');

		return builder.toString();
	}


	public $var.type$ sum() {
		return sum(this);
	}


	public $var.averageType$ average() {
		return average(this);
	}


	public $var.type$ max() {
		return max(this);
	}


	public $var.type$ min() {
		return min(this);
	}


	@SafeVarargs
	public static final $var.className$ of($var.type$... values) {
		$var.className$ inst = new $var.className$();
		inst.addAll(values);
		return inst;
	}


	public static final $var.type$ sum($var.className$ list) {
		$var.type$[] values = list.data;
		$var.type$ sum = 0;
		for(int i = 0, size = list.size; i < size; i++) {
			sum += values[i];
		}
		return sum;
	}


	public static final float average($var.className$ list) {
		return (float)sum(list) / list.size;
	}


	public static final $var.type$ max($var.className$ list) {
		if(list.size > 0) {
			return list.data[list.size() - 1];
		}
		return $var.defaultValue$;
	}


	public static final $var.type$ min($var.className$ list) {
		if(list.size > 0) {
			return list.data[0];
		}
		return $var.defaultValue$;
	}

}

>>
