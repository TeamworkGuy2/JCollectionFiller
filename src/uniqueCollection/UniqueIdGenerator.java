package uniqueCollection;

import java.util.function.IntConsumer;

import primitiveCollections.IntListSorted;

/** Generates and maintains a unique list of integer IDs.<br>
 * IDs that are {@link #deleteId(int) deleted} may later be reused.<br>
 * Performance note: creating a large number of IDs and then deleting most of them without
 * adding any new IDs may cause some memory overhead, since each deleted
 * ID must be tracked for possible reuse.
 * @author TeamworkGuy2
 * @since 2013-4-2
 */
public class UniqueIdGenerator {
	private int counter;
	private int lastId;
	private int highestId;
	private IntListSorted unusedIds;
	@SuppressWarnings("unused")
	private volatile int mod;


	public UniqueIdGenerator() {
		counter = 0;
		lastId = -1;
		highestId = -1;
		unusedIds = new IntListSorted();
		mod = 0;
	}


	public UniqueIdGenerator copy() {
		UniqueIdGenerator copy = new UniqueIdGenerator();
		copy.counter = this.counter;
		copy.lastId = this.lastId;
		copy.highestId = this.highestId;
		copy.unusedIds = this.unusedIds.copy();
		return copy;
	}


	/** Create a new unique ID
	 * @return the new unique ID generated by this generator within the range [0, Integer.MAX_VALUE-1]
	 * @throws IllegalStateException if the ID generator has generated all IDs up to Integer.MAX_VALUE-1,
	 * no further values can be generated until one of the generated values is deleted.
	 */
	public int createId() {
		int newIndex = -1;
		if(unusedIds.isEmpty()) {
			newIndex = counter;
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
			if(counter == Integer.MAX_VALUE) {
				throw new IllegalStateException("maximum number of unique integer IDs exceeded");
			}
			counter++;
		}
		else {
			newIndex = unusedIds.remove(unusedIds.size() - 1);
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
		}
		mod++;
		return newIndex;
	}


	/** Delete the specified unique ID from this generator
	 * @param id the ID to delete
	 * @return true if the ID was deleted successfully, false otherwise
	 */
	public boolean deleteId(int id) {
		if(contains(id)) {
			mod++;
			if(id == counter - 1) {
				counter--;
				return true;
			}
			else {
				unusedIds.add(id);
				return true;
			}
		}
		return false;
	}


	/** Get the last unique ID generated by this generator
	 * @return the last unique ID generated by this generator
	 */
	public int getLastId() {
		return lastId;
	}


	/** Get the highest unique ID generated by this generator
	 * @return the highest unique ID generated by this generator
	 */
	public int getHighestId() {
		return highestId;
	}


	/** The number of currently undeleted unique IDs generated by this generator
	 * @return the number of undeleted IDs from this generator
	 */
	public int size() {
		return counter - unusedIds.size();
	}


	/** Check if this group of unique IDs contains the specified ID.<br/>
	 * This method runs in average <code>O(log n)</code> time where <code>n</code> is the number of IDs in
	 * this generator.
	 * @param id the ID to check for in this generator's group of unique IDs.
	 * @return true if the input ID is one of this generator's ID's, false otherwise.
	 */
	public boolean contains(int id) {
		return (id > -1 && id < counter && !unusedIds.contains(id));
	}


	public void forEach(IntConsumer task) {
		int unusedIndex = unusedIds.size() > 0 ? 0 : -1;
		int nextUnused = unusedIndex > -1 ? unusedIds.get(unusedIndex) : -1;
		for(int i = 0; i < counter; i++) {
			if(unusedIndex > -1 && i == nextUnused) {
				unusedIndex = unusedIndex + 1 >= unusedIds.size() ? -1 : unusedIndex + 1;
				nextUnused = unusedIndex > -1 ? unusedIds.get(unusedIndex) : -1;
			}
			else {
				task.accept(i);
			}
		}
	}


	@Override
	public String toString() {
		return "Unique IDs " + size() + ", last Id: " + lastId;
	}

}
