package uniqueCollection;

import java.util.Arrays;
import java.util.function.IntConsumer;

import primitiveCollections.IntListSorted;

/** Generates and maintains and a unique list of integer IDs
 * using a byte array for fast lookup of valid IDs which incurs
 * a ~1 byte overhead per ID.
 * @author TeamworkGuy2
 * @since 2013-4-2
 */
public class UniqueIdArray {
	private static int defaultSize = 16;
	private static byte USED_VALUE = 1;
	private static byte EMPTY_VALUE = 0;
	private int size;
	private int lastId;
	private int highestId;
	private byte[] usedIds;
	private IntListSorted unusedIds;


	public UniqueIdArray() {
		size = 0;
		lastId = -1;
		highestId = -1;
		unusedIds = new IntListSorted();
		usedIds = new byte[defaultSize];
	}


	public UniqueIdArray copy() {
		UniqueIdArray copy = new UniqueIdArray();
		copy.size = this.size;
		copy.lastId = this.lastId;
		copy.highestId = this.highestId;
		copy.usedIds = Arrays.copyOf(usedIds, usedIds.length);
		copy.unusedIds = this.unusedIds.copy();
		return copy;
	}


	/** Create a new unique ID
	 * @return the new unique ID generated by this generator within the range [0, Integer.MAX_VALUE-1]
	 * @throws IllegalStateException if the ID generator has generated all IDs up to Integer.MAX_VALUE-1,
	 * no further values can be generated until one of the generated values is deleted.
	 */
	public int createId() {
		int newIndex = -1;
		// If there are no unused IDs, create a new one
		if(unusedIds.size() == 0) {
			newIndex = size;
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
			if(size == Integer.MAX_VALUE) {
				throw new IllegalStateException(this.getClass().getSimpleName() + " ran out of unique IDs.");
			}
			size++;
			if(size >= usedIds.length) {
				expandList();
			}
		}
		// Else reuse one of the previously deleted IDs
		else {
			newIndex = unusedIds.remove(unusedIds.size()-1);
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
		}
		if(usedIds[newIndex] != EMPTY_VALUE) {
			throw new InternalError("Error finding internal unused index");
		}
		usedIds[newIndex] = USED_VALUE;
		return newIndex;
	}


	/** Delete the specified unique ID from this generator
	 * @param id the ID to delete
	 * @return true if the ID was deleted successfully, false otherwise
	 */
	public boolean deleteId(int id) {
		if(contains(id)) {
			if(id == size - 1) {
				usedIds[id] = EMPTY_VALUE;
				size--;
				return true;
			}
			else {
				unusedIds.add(id);
				usedIds[id] = EMPTY_VALUE;
				return true;
			}
		}
		return false;
	}


	/** Get the last unique ID generated by this generator
	 * @return the last unique ID generated by this generator
	 */
	public int getLastId() {
		return lastId;
	}


	/** Get the highest unique ID generated by this generator
	 * @return the highest unique ID generated by this generator
	 */
	public int getHighestId() {
		return highestId;
	}


	/** The number of currently undeleted unique IDs generated by this generator
	 * @return the number of undeleted IDs from this generator
	 */
	public int size() {
		return size - unusedIds.size();
	}


	/** Check if this group of unique IDs contains the specified ID.<br/>
	 * This method runs in average <code>O(log n)</code> time where <code>n</code> is the number of IDs in
	 * this generator.
	 * @param id the ID to check for in this generator's group of unique IDs.
	 * @return true if the input ID is one of this generator's ID's, false otherwise.
	 */
	public boolean contains(int id) {
		return (id > -1 && id < size && usedIds[id] == USED_VALUE);
	}


	public void forEach(IntConsumer task) {
		for(int i = 0, count = size; i < count; i++) {
			if(usedIds[i] == USED_VALUE) {
				task.accept(i);
			}
		}
	}


	@Override
	public String toString() {
		return "Unique IDs " + size() + ", last Id: " + lastId;
	}


	private final void expandList() {
		byte[] oldIds = this.usedIds;
		int size = oldIds.length;
		// 1.5x + 4 the ID array size, +4 instead of +1 to help keep
		// small lists from constantly resizing
		this.usedIds = new byte[size + (size >>> 1) + 4];
		System.arraycopy(oldIds, 0, usedIds, 0, size);
	}

}
