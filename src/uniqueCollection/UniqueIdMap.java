package uniqueCollection;

import java.util.HashMap;
import java.util.RandomAccess;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import primitiveCollections.IntListSorted;

/** A list of unique integer ID and object pairs.
 * The {@link #get(int)}, {@link #setValue(int, Object)}, {@link #deleteId(int)},
 * and {@link #containsId(int)} operations are O(1) worst case.
 * The {@link #containsValue(Object) containsValue(T)}, {@link #createId(Object) createId(T)},
 * {@link #deleteValue(Object) deleteValue(T)} operations are O(n) worst case.<br/>
 * This collection maintains a reference to every used and unused ID up to {@link #getHighestId()}.
 * Heavy fragmentation due to adding a large number of items and then deleted 
 * the majority of them will cause some memory overhead. If this is unacceptable,
 * you should consider using a collection that maintains a unique list of
 * ID-value pairs without overhead memory usage, such as a {@link HashMap}.
 * @param <T> the type of value to store with each ID
 * @author TeamworkGuy2
 * @since 2013-4-2
 */
public class UniqueIdMap<T> implements RandomAccess {
	/** Used to represent null data values, unused empty array elements contain the value <code>null</code> */
	private static Object NULL_VALUE = new Object();
	private Object[] values;
	private int size;
	private int lastId;
	private int highestId;
	private IntListSorted unusedIds;


	/** Create a group of unique identifiers with associated items with a default size of 16
	 */
	public UniqueIdMap() {
		this(16);
	}


	/** Create a group of unique identifiers and associated objects with the specified size as the starting size
	 * @param capacity the initial size of the group of items
	 */
	public UniqueIdMap(int capacity) {
		values = new Object[capacity];
		size = 0;
		lastId = -1;
		highestId = -1;
		unusedIds = new IntListSorted();
	}


	public final UniqueIdMap<T> copy() {
		UniqueIdMap<T> newList = new UniqueIdMap<T>(values.length);
		newList.size = size;
		newList.lastId = lastId;
		newList.highestId = highestId;
		newList.unusedIds = unusedIds.copy();
		System.arraycopy(values, 0, newList.values, 0, size);
		return newList;
	}


	/** Get the object at the specified index
	 * @param index the index between zero and {@link #size()}-1 inclusive to retrieve
	 * @return the object found at the specified index
	 */
	@SuppressWarnings("unchecked")
	public final T get(int index) {
		if(!containsId(index)) { throw new ArrayIndexOutOfBoundsException(index); }
		return (T)values[index];
	}


	/** Get the value associated with the specified ID if it is a valid ID
	 * @param id the unique ID to retrieve the value of
	 * @return the value associated with the specified ID if it exists.
	 * This value will be null if the ID does not exist, but may also be null
	 * if the ID is found and the value associated with the ID is null.
	 * Use {@link #containsId(int)} to differentiate between these cases.
	 */
	@SuppressWarnings("unchecked")
	public final T getId(int id) {
		if(!containsId(id)) { return null; }
		return (T)values[id];
	}


	/** Set the value associated with a specific ID
	 * @param id the identifier that's value is to be set
	 * @param value the value to set for the ID
	 * @return true if the value was set successfully, false otherwise
	 */
	public final boolean setValue(int id, T value) {
		if(!containsId(id) || value == NULL_VALUE) { throw new ArrayIndexOutOfBoundsException(id); }
		// All null values are converted to the NULL_VALUE value
		values[id] = (value == null ? NULL_VALUE : value);
		return true;
	}


	/** Check if this group of unique IDs contains the specified ID.<br/>
	 * This method runs in average <code>O(n)</code> time where <code>n</code> is the number of IDs in this generator.
	 * @param id the ID to check for in this generator's group of unique IDs.
	 * @return true if the input ID is one of this generator's IDs, false otherwise.
	 */
	public final boolean containsId(int id) {
		return (id > -1 && id < size && values[id] != null);
	}


	/** Get the last unique ID generated by this generator
	 * @return the last unique ID generated by this generator
	 */
	public final int getLastId() {
		return lastId;
	}


	/** Get the highest unique ID generated by this generator
	 * @return the highest unique ID generated by this generator
	 */
	public final int getHighestId() {
		return highestId;
	}


	/** Check if the specified values is contained in this list of integers
	 * @param value the value to check for in this list
	 * @return true if the value was found in the list, false otherwise
	 */
	@SuppressWarnings("unchecked")
	public final boolean containsValue(T value) {
		// all null objects are stored as NULL_VALUE values
		value = (value == null ? (T)NULL_VALUE : value);
		// Search for the item to remove
		int currentSkipValue = unusedIds.size() > 0 ? unusedIds.get(0) : Integer.MAX_VALUE;
		int currentSkipIndex = 0;
		// Use .equals() if the value is not NULL_VALUE (meaning a null object)
		if(value != NULL_VALUE) {
			for(int i = 0; i < size; i++) {
				// If the item is found, return true, values[i] will only be null if the current value should
				// be skipped which is handled by the currentSkipValue
				if(i != currentSkipValue && values[i].equals(value)) {
					return true;
				}
				if(i == currentSkipValue) {
					currentSkipIndex++;
					currentSkipValue = unusedIds.size() > currentSkipIndex ? unusedIds.get(currentSkipIndex) : Integer.MAX_VALUE;
				}
			}
		}
		// Use == NULL_VALUE if the value is null
		else {
			for(int i = 0; i < size; i++) {
				// If a null item is found, return true
				if(values[i] == NULL_VALUE && i != currentSkipValue) {
					return true;
				}
				if(i == currentSkipValue) {
					currentSkipIndex++;
					currentSkipValue = unusedIds.size() > currentSkipIndex ? unusedIds.get(currentSkipIndex) : Integer.MAX_VALUE;
				}
			}
		}
		// Else if the item is not found, return false
		return false;
	}


	/** Create a new unique ID
	 * @param value the value to associate with the newly created ID
	 * @return the new unique ID generated by this generator within the range [0, Integer.MAX_VALUE-1]
	 * @throws IllegalStateException if the ID generator has generated all IDs up to Integer.MAX_VALUE-1,
	 * no further values can be generated until one of the generated values is deleted.
	 */
	@SuppressWarnings("unchecked")
	public final int createId(T value) {
		if(value == NULL_VALUE) { throw new IllegalArgumentException("invalid input object"); }
		value = (value == null ? (T)NULL_VALUE : value);
		int newIndex = -1;
		// Look for an unused index to create new unique identifier from
		if(unusedIds.size() == 0) {
			newIndex = size;
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
			if(size == Integer.MAX_VALUE) {
				throw new IllegalStateException("UniqueIdMap ran out of unique IDs.");
			}
			size++;
			// Expand the size of the data array if the array is full
			if(size >= values.length) {
				expandList();
			}
		}
		else {
			newIndex = unusedIds.remove(unusedIds.size()-1);
			lastId = newIndex;
			if(lastId > highestId) { highestId = lastId; }
		}
		// Store the associated object in the index found
		values[newIndex] = value;
		return newIndex;
	}


	/** Delete the specified unique ID from this generator
	 * @param id the ID to delete
	 * @return the object associated with the the ID if the ID was deleted successfully, null otherwise
	 */
	public final T deleteId(int id) {
		Object value = null;
		// If the identifier is a valid index, remove it and add it to the unused identifier list
		if(containsId(id)) {
			if(id == size-1) {
				value = values[id];
				values[id] = null;
				size--;
			}
			else {
				unusedIds.add(id);
				value = values[id];
				values[id] = null;
			}
		}
		@SuppressWarnings("unchecked")
		T val = (T)value;
		return val;
	}


	/** Delete the specified values from this list of values
	 * @param value the value to check for in this list
	 * @return the value associated with the object deleted from this list,
	 * or -1 if the object could not be found 
	 */
	@SuppressWarnings("unchecked")
	public final int deleteValue(T value) {
		if(value == NULL_VALUE) { throw new IllegalArgumentException("invalid input object"); }
		value = (value == null ? (T)NULL_VALUE : value);
		// Search for the item to remove
		int currentSkipValue = unusedIds.size() > 0 ? unusedIds.get(0) : Integer.MAX_VALUE;
		int currentSkipIndex = 0;
		for(int i = 0; i < size; i++) {
			// If the item is found, return true, values[i] will only be null if the current value should
			// be skipped which is handled by the currentSkipValue
			if(i != currentSkipValue && values[i].equals(value)) {
				if(i == size-1) {
					values[i] = null;
					size--;
				}
				else {
					unusedIds.add(i);
					values[i] = null;
				}
				return i;
			}
			// If the current counter value is equal to the current unused index, get the next unused index
			if(i == currentSkipValue) {
				currentSkipIndex++;
				currentSkipValue = unusedIds.size() > currentSkipIndex ? unusedIds.get(currentSkipIndex) : Integer.MAX_VALUE;
			}
		}
		// Else if the item is not found, return false
		return -1;
	}


	/** Clear the group of id and object associations from this unique identifier list
	 */
	public final void clear() {
		// Clear the array of values to null
		for(int i = 0; i < size; i++) {
			values[i] = null;
			unusedIds.clear();
		}
		// Set the size back to the beginning of the array
		size = 0;
	}


	/** The number of currently valid unique IDs stored in this generator
	 * @return the number of valid IDs in this generator
	 */
	public final int size() {
		return size - unusedIds.size();
	}


	/** Is this group of elements empty
	 * @return true if this group of elements is empty, false otherwise
	 */
	public final boolean isEmpty() {
		return (size-unusedIds.size()) == 0;
	}


	public void forEach(BiConsumer<Integer, T> task) {
		for(int i = 0, count = size; i < count; i++) {
			@SuppressWarnings("unchecked")
			T val = (T)values[i];
			if(val != null) {
				task.accept(i, val);
			}
		}
	}


	/** Expand this unique ID list's array of values
	 */
	private final void expandList() {
		Object[] oldValues = this.values;
		// 1.5x + 4 the ID array size, +4 instead of +1 to help keep
		// small lists from constantly resizing
		this.values = new Object[oldValues.length + (oldValues.length >> 1) + 4];
		System.arraycopy(oldValues, 0, this.values, 0, oldValues.length);
	}


	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.setLength(0);
		builder.append("UniqueIdList ");
		builder.append(size());
		builder.append(" array pos: ");
		builder.append(size);
		builder.append(" [");
		// Search for the item to remove
		int currentSkipValue = unusedIds.size() > 0 ? unusedIds.get(0) : Integer.MAX_VALUE;
		int currentSkipIndex = 0;
		int sizeTemp = size-1;
		for(int i = 0; i < sizeTemp; i++) {
			// If the item is found, return true
			if(i != currentSkipValue) {
				builder.append(values[i]);
				builder.append(", ");
			}
			else {
				currentSkipIndex++;
				currentSkipValue = unusedIds.size() > currentSkipIndex ? unusedIds.get(currentSkipIndex) : Integer.MAX_VALUE;
			}
		}
		if(containsId(sizeTemp)) {
			builder.append(values[sizeTemp]);
		}
		builder.append("]");
		return builder.toString();
	}


	public void forEach(Consumer<? super T> action) {
		for(int i = 0; i < size; i++) {
			@SuppressWarnings("unchecked")
			T value = (T)values[i];
			if(value != null) {
				action.accept(value);
			}
		}
	}

}
